import altair as alt
import numpy as np
import pandas as pd
import streamlit as st

"""
# Welcome to Streamlit!

Edit `/streamlit_app.py` to customize this app to your heart's desire :heart:.
If you have any questions, checkout our [documentation](https://docs.streamlit.io) and [community
forums](https://discuss.streamlit.io).

In the meantime, below is an example of what you can do with just a few lines of code:
"""

# -*- coding: utf-8 -*-
"""Modelling from Surface Profile - Double Concave Lens.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/188g6NYWqOkJgRHDlwt__nL7yFQhq60oJ

Author: Jain Iftesam

Contact: jainiftesam6@gmail.com


This program simulates light rays passing through a double concave lens, similar to a projector.
"""

!git clone https://github.com/guo-research-group/AD-Ray-Optics

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/AD-Ray-Optics
!python setup.py develop

pip install -r requirements.txt

from rayoptics import *

import jax.numpy as jnp
from jax import grad, jit, vmap
from jax import random

from rayoptics.environment import *
import random
from copy import deepcopy
from scipy.optimize import minimize
import numpy as np

import jax
import jax.numpy as jnp
from jax import grad, jit, vmap
from jax.numpy import sqrt, copysign, sin
jax.config.update("jax_enable_x64", True)

from rayoptics.environment import *
from rayoptics.mpl.interactivediagram import InteractiveDiagram

from jax import lax

isdark = False

def lens(f, R1, R2, d_L, wv, n, pupil_r, p1=[0],p2=[0]):
    opm = OpticalModel()
    sm  = opm['seq_model']
    osp = opm['optical_spec']
    pm = opm['parax_model']
    em = opm['ele_model']
    pt = opm['part_tree']
    ar = opm['analysis_results']
    osp['pupil'] = PupilSpec(osp, key=['object', 'pupil'], value=pupil_r*2)
    osp['fov'] = FieldSpec(osp, key=['object', 'angle'], value=2.5, flds=[0., 0.707, 1.], is_relative=True)
    osp['wvls'] = WvlSpec([('F', 0.5), (wv, 1.0), ('C', 0.5)], ref_wl=1)

    opm.radius_mode = True

    sm.gaps[0].thi = 3
    remaining_height = f
    d_L = 0


    # the front surface of the lens is a sphere plus some radial polynomial defined by p
    sm.add_surface([-abs(R1), d_L, n, pupil_r])  # Make R1 negative
    sm.ifcs[sm.cur_surface].profile = RadialPolynomial(r=-abs(R1), coefs=p1)  # Make R1 negative
    sm.set_stop()

    remaining_height -= d_L
    # the back surface of the lens is a sphere
    sm.add_surface([abs(R2), d_L, 1, pupil_r])  # Make R2 negative
    sm.ifcs[sm.cur_surface].profile = RadialPolynomial(r=abs(R2), coefs=p1)  # Make R2 negative
    sm.set_stop()


    sm.gaps[-1].thi = 5
    opm.update_model()

    return sm

from visualize.rays import visualize_rays
from visualize.lens import visualize_lens
import plotly.graph_objects as go

# This cell simulates a lens without any correction
#f = 8 # focal length in mm
wv = 400.5618
pupil_r = 1.5
n = 1.5 # refractive index
R2 = 15 # radius of the first surface, mm
R1 = 15
f = 8 # lens maker equation
d_L = 1.5 # lens thickness

# max_angle = 1/180*np.pi*10 # max incident angle, rad
# set visualization parameters
radius = 3
rays = 25
x_offsets = list(np.linspace(-radius, radius, rays))
y_offsets = list(np.linspace(-radius, radius, rays))
z_offsets = [0] * rays
num_rays = 1

sm = lens(f, R1, R2, d_L, wv, n, pupil_r)
ray_data = visualize_rays(sm, radius=radius*0.4, wv=wv, x_offsets=x_offsets, y_offsets=y_offsets, num_rays=num_rays)
lens_data = visualize_lens(sm, radius=radius)
data = []
data.extend(ray_data)
data.extend(lens_data)
fig = go.Figure(data = data)
fig.show()

# num_points = st.slider("Number of points in spiral", 1, 10000, 1100)
# num_turns = st.slider("Number of turns in spiral", 1, 300, 31)

# indices = np.linspace(0, 1, num_points)
# theta = 2 * np.pi * num_turns * indices
# radius = indices

# x = radius * np.cos(theta)
# y = radius * np.sin(theta)

# df = pd.DataFrame({
#     "x": x,
#     "y": y,
#     "idx": indices,
#     "rand": np.random.randn(num_points),
# })

# st.altair_chart(alt.Chart(df, height=700, width=700)
#     .mark_point(filled=True)
#     .encode(
#         x=alt.X("x", axis=None),
#         y=alt.Y("y", axis=None),
#         color=alt.Color("idx", legend=None, scale=alt.Scale()),
#         size=alt.Size("rand", legend=None, scale=alt.Scale(range=[1, 150])),
#     ))
